#!/usr/bin/python

# mwatch - Watches topics change from an MQTT broker
#
# By Dennis Sell
#
# Inspired by subcurses written by Andrew Elwell <Andrew.Elwell@ivec.org>



#BUGS
# heading does not scroll right to left yet!
# resizing terminal crashes.  Possibly some curses/mosquitto interaction.


import os
import sys
import getopt
import mosquitto
import curses
from curses.ascii import isprint
import time
import datetime

version_number = 0.5
topiclist = []
count = []
numtopics = 0
rxcount = 0
pos = 0
col = 0
topic_col = 0
topic_size = 60
retained_col = topic_size
qos_col = topic_size
count_col = topic_size
timestamp_col = topic_size
message_col = topic_size


def usage():
    print "usage: mwatch [options]"  #[hostname[:port]] [topics]" 
    print "Watch topics change from an MQTT broker."
    print 
    print "   -u --hostname HOSTNAME set hostname for broker (default localhost)"
    print "   -p --port PORT         set port for mqtt broker (default 1883)"
    print "   -t --topics TOPICS     set topics to watch (default /#)"
    print "   -q --qos               show QOS as recieved"
    print "   -r --retained          show retained status"
    print "   -c --count             show count of receptions"
    print "   -s --timestamp         show timestamp of message reception"
    print "   -a --all               show all data fields"
    print "   -x --hex               show message in hex"
    print "   -h --help              show this help information"
    print "   -v --version           show version information"
    print "By Dennis Sell -- 2013"

def version():
    print "version: " + str(version_number)


def on_connect(mosq, userdata, rc):
    stdscr.addstr(curses.LINES-1,0,"Connected to %s" % broker)
    stdscr.addstr(0,15,"Sunscribed to %s" % topics, curses.A_REVERSE)
    stdscr.noutrefresh()
    curses.doupdate()

def isprintable(v):
    ret = True
    for char in v:
        if not curses.ascii.isprint(char):    
            ret = False
    return ret

def on_message(mosq, userdata, msg):
    global numtopics
    global rxcount
    global retained_flag
    global timestamp_flag

    rxcount = rxcount + 1
    stdscr.addstr(0,80,"Msg count %s" % rxcount, curses.A_REVERSE)
    if msg.topic not in topiclist:
        topiclist.append(msg.topic)
        numtopics = numtopics + 1
        count.append(0)
        stdscr.addstr(0,60,"Topic count %s" % numtopics, curses.A_REVERSE)
    offset = topiclist.index(msg.topic) 
    count[offset] = count[offset] + 1
    stats_txt.addstr(offset, message_col, "                                                                                                                                 ")
    stats_txt.addstr(offset, topic_col, msg.topic)
    if isprintable(msg.payload) and not hex_flag:
        stats_txt.addstr(offset, message_col, msg.payload)
    else:
        #  v = " ".join([hex(ord(a)) for a in msg.payload])  #Does individual bytes.
        stats_txt.addstr(offset, message_col, "####  NON-ALPHANUMERIC  #### --> 0x" + msg.payload.encode('hex')) #v)
    if msg.retain:
        retained_value = "True "
    else:
        retained_value = "False"
    if retained_flag:
        stats_txt.addstr(offset, retained_col, retained_value)
    if qos_flag:
        stats_txt.addstr(offset, qos_col, str(msg.qos))
    if count_flag:
        stats_txt.addstr(offset, count_col, str(count[offset]))
    if timestamp_flag:
        stats_txt.addstr(offset, timestamp_col, str(datetime.datetime.now()))
    stats_txt.refresh(pos, col, 3,2, page,curses.COLS-4)
    curses.doupdate()

def getTerminalSize():
    """
    returns (lines:int, cols:int)
    """
    import os, struct
    def ioctl_GWINSZ(fd):
        import fcntl, termios
        return struct.unpack("hh", fcntl.ioctl(fd, termios.TIOCGWINSZ, "1234"))
    # try stdin, stdout, stderr
    for fd in (0, 1, 2):
        try:
            return ioctl_GWINSZ(fd)
        except:
            pass
    # try os.ctermid()
    try:
        fd = os.open(os.ctermid(), os.O_RDONLY)
        try:
            return ioctl_GWINSZ(fd)
        finally:
            os.close(fd)
    except:
        pass
    # try `stty size`
    try:
        return tuple(int(x) for x in os.popen("stty size", "r").read().split())
    except:
        pass
    # try environment variables
    try:
        return tuple(int(os.getenv(var)) for var in ("LINES", "COLUMNS"))
    except:
        pass
    # i give up. return default.
    return (25, 80)


try:
    opts, args = getopt.getopt(sys.argv[1:], 'u:p:t:rqcsaxhv', ['hostname=', 'port=', 'topics=', 'retained', 'qos', 'count', 'timestamp', 'all', 'hex', 'help', 'version'])
except getopt.GetoptError as err:
    print str(err)
    usage()
    sys.exit(2)


# defaults
broker = "127.0.0.1"
port = 1883
topics = "/#"
retained_flag = False
qos_flag = False
count_flag = False
timestamp_flag = False
hex_flag = False

for opt, arg in opts:
    if opt in ('-h', '--help'):
        usage()
        sys.exit(2)
    if opt in ('-v', '--version'):
        version()
        sys.exit(2)
    elif opt in ('-u', '--hostname'):
        broker = arg
    elif opt in ('-p', '--port'):
        port = arg
    elif opt in ('-t', '--topics'):
        topics = arg
    elif opt in ('-r', '--retained'):
        retained_flag = True
    elif opt in ('-q', '--qos'):
        qos_flag = True
    elif opt in ('-c', '--count'):
        count_flag = True
    elif opt in ('-s', '--timestamp'):
        timestamp_flag = True
    elif opt in ('-a', '--all'):
        retained_flag = True
        qos_flag = True
        count_flag = True
        timestamp_flag = True
    elif opt in ('-x', '--hex'):
        hex_flag = True
    else:
        usage()
        sys.exit(2)


# minitialize mosquitto, connect, and subscribe
client = mosquitto.Mosquitto()
client.on_message = on_message
client.on_connect = on_connect
client.connect(broker)
if qos_flag:
    qos = 2
else:
    qos = 0
client.subscribe(topics, qos=qos)

# initialize curses
stdscr = curses.initscr()
stdscr.nodelay(1)
curses.curs_set(0)
if curses.has_colors():
    curses.start_color()
curses.cbreak()
curses.noecho()
stdscr.keypad(1)


# draw basic screen
stdscr.addstr("MQTT watch ", curses.A_REVERSE)
stdscr.chgat(-1,curses.A_REVERSE)
stdscr.addstr(curses.LINES-1,curses.COLS-45,"page-up, page-dn, cursor arrows, q to Quit")
page = curses.LINES - 3
stats = curses.newwin(curses.LINES-2,curses.COLS,1,0)
stats.box()
header_txt = curses.newpad(1,2000)
stats_txt = curses.newpad(2000,2000)
stats_txt.refresh(pos, col, 3,2, page,curses.COLS-4)
stdscr.noutrefresh()
stats.noutrefresh()


header_txt.addstr(0, topic_col+1, "TOPIC", curses.A_UNDERLINE)
if retained_flag:
    qos_col = qos_col + 10
    timestamp_col = timestamp_col + 10
    count_col = count_col + 10
    message_col = message_col + 10
    if curses.COLS > retained_col + 2:
        header_txt.addstr(0, retained_col+1, "RETAINED", curses.A_UNDERLINE)
if qos_flag:
    timestamp_col = timestamp_col + 5
    count_col = count_col + 5
    message_col = message_col + 5
    header_txt.addstr(0, qos_col+1, "QOS", curses.A_UNDERLINE)
if count_flag:
    timestamp_col = timestamp_col + 7
    message_col = message_col + 7
    header_txt.addstr(0, count_col+1, "COUNT", curses.A_UNDERLINE)
if timestamp_flag:
    message_col = message_col + 28
    header_txt.addstr(0, timestamp_col+1, "RECEIVED TIMESTAMP", curses.A_UNDERLINE)
if curses.COLS > message_col + 10:
    header_txt.addstr(0, message_col+1, "MESSAGE", curses.A_UNDERLINE)
header_txt.refresh(0, 0, 2, 1, 2, curses.COLS-4)
stats.noutrefresh()
curses.doupdate()

# main loop
while client.loop(0) == 0:
    key = stdscr.getch()
    if key == ord("q"):
        break
    if key == curses.KEY_DOWN:
        pos = pos + 1
        if pos > numtopics:
            pos = numtopics
        stats_txt.refresh(pos, col, 3,2, page,curses.COLS-4)
        header_txt.refresh(0, col, 2, 1, 2, curses.COLS-4)
        curses.doupdate()
    if key == curses.KEY_UP:
        pos = pos - 1
        if pos < 0:
            pos = 0
        stats_txt.refresh(pos, col, 3,2, page,curses.COLS-4)
        header_txt.refresh(0, col, 2, 1, 2, curses.COLS-4)
        curses.doupdate()
    if key == curses.KEY_NPAGE:
        pos = pos + page - 2
        if pos > numtopics:
            pos = numtopics
        stats_txt.refresh(pos, col, 3,2, page,curses.COLS-4)
        header_txt.refresh(0, col, 2, 1, 2, curses.COLS-4)
        curses.doupdate()
    if key == curses.KEY_PPAGE:
        pos = pos - page + 2
        if pos < 0:
            pos = 0
        stats_txt.refresh(pos, col, 3,2, page,curses.COLS-4)
        header_txt.refresh(0, col, 2, 1, 2, curses.COLS-4)
        curses.doupdate()
    if key == curses.KEY_LEFT:
        col = col - 1
        if col < 0:
            col = 0
        stats_txt.refresh(pos, col, 3,2, page,curses.COLS-4)
        header_txt.refresh(0, col, 2, 1, 2, curses.COLS-4)
        curses.doupdate()
    if key == curses.KEY_RIGHT:
        col = col + 1
        if col < 0:
            col = 1000
        stats_txt.refresh(pos, col, 3,2, page,curses.COLS-4)
        header_txt.refresh(0, col, 2, 1, 2, curses.COLS-4)
        curses.doupdate()
    if key == curses.KEY_HOME:
        pos = 0
        col = 0
        stats_txt.refresh(pos, col, 3,2, page,curses.COLS-4)
        header_txt.refresh(0, col, 2, 1, 2, curses.COLS-4)
        curses.doupdate()
    if key == curses.KEY_RESIZE:    #Resizing the terminal screen crashes this program.  
        l, c = getTerminalSize()    #It seems to be something to do with calling the mosquitto library in the above while loop.  
        if c > 50:                  #Redrawing belongs here if the problem gets solved.
            stdscr.addstr(0, curses.COLS-20, "Col: " + str(c) + "  Lines: " + str(l))
    l, c = getTerminalSize()
    if c > 120:                 
        stdscr.addstr(0,c - 27,"%s" % str(datetime.datetime.now()), curses.A_REVERSE)
    pass


# clean up terminal settings
curses.nocbreak()
stdscr.keypad(0)
curses.echo()
curses.endwin()

